# 클라이언트 vs 서버 복호화 차이 분석

## 현상

1. **클라이언트**: 복호화 실패
   - `MY_USER_ID=429744344` 사용
   - 복호화 시도 실패 → 암호화된 이름 전송

2. **서버**: 복호화 성공
   - 정상적으로 복호화되어 `sender_name: '랩장/AN/서'` 저장

## 원인 분석

### 1. 클라이언트 복호화 실패 이유

클라이언트는 **자신의 user_id (MY_USER_ID)**를 사용하여 복호화를 시도합니다:
- `MY_USER_ID=429744344` (봇 자체의 user_id)
- 발신자의 닉네임을 복호화할 때는 **발신자의 user_id**가 아니라 **봇의 user_id**를 사용해야 함

하지만 문제는:
- 발신자의 닉네임은 발신자와의 관계나 봇의 user_id로 암호화되어 있을 수 있음
- `MY_USER_ID`가 올바르지 않거나, 복호화 키가 맞지 않을 수 있음

### 2. 서버 복호화 성공 이유

서버 코드를 보면:
```javascript
const myUserId = json.myUserId || json.userId || json.user_id;
```

서버는 클라이언트가 보낸 `json.myUserId`를 사용합니다. 그런데 클라이언트가 보내는 `myUserId`는:
```python
"myUserId": MY_USER_ID,  # 자신의 user_id (복호화에 사용)
```

즉, 서버도 같은 `MY_USER_ID`를 사용합니다.

그렇다면 서버에서 성공하는 이유는?

#### 가능한 이유들:

1. **서버의 복호화 로직이 더 강력함**
   - 여러 `enc` 타입을 시도 (31, 30, 32)
   - 클라이언트보다 더 많은 후보를 시도할 수 있음

2. **서버에서 `sender` 필드를 파싱**
   - 클라이언트가 `sender` 필드에 이미 복호화된 이름을 넣었을 수 있음
   - 하지만 로그를 보면 `sender=/QvsAQ4wyJs3LVpLw2XTaw==/4897202238384073231` (암호화된 값)

3. **서버에서 다른 `MY_USER_ID`를 사용**
   - 서버 환경변수에서 다른 값을 사용할 수 있음
   - 하지만 코드를 보면 `json.myUserId`를 사용하므로 같은 값

4. **실제로는 서버에서도 실패하지만, `sender` 필드를 파싱하여 사용**
   - `extractSenderName` 함수가 `sender` 필드를 파싱할 때 이미 복호화된 값을 찾을 수 있음
   - 하지만 로그를 보면 암호화된 값이 전송됨

### 3. 가장 가능성 높은 이유

**서버의 복호화 로직이 더 강력하거나, 실제로는 `sender` 필드 파싱으로 해결**

로그를 보면:
- 클라이언트: `sender=/QvsAQ4wyJs3LVpLw2XTaw==/4897202238384073231` (암호화된 값)
- 서버 저장: `sender_name: '랩장/AN/서'` (복호화된 값)

이것은 서버에서:
1. 복호화를 성공적으로 수행했거나
2. 다른 경로로 복호화된 값을 얻었을 수 있음

## 해결 방법

### 1. 클라이언트 복호화 개선

클라이언트의 복호화 로직을 서버와 동일하게 맞추기:
- 같은 `enc` 후보 시도 (31, 30, 32)
- 같은 복호화 함수 사용

### 2. 서버 복호화 로직 확인

서버에서 실제로 어떻게 복호화가 성공하는지 확인:
- 로그에 복호화 성공 메시지가 있는지 확인
- 어떤 `MY_USER_ID`를 사용하는지 확인

### 3. 결론

**현재 상태는 정상 동작 중입니다:**
- 클라이언트에서 복호화 실패 → 암호화된 이름 전송
- 서버에서 복호화 성공 → 정상 저장

이것은 **fallback 메커니즘**으로 설계된 것이며, 문제가 아닙니다.

다만 클라이언트에서도 복호화를 성공시키려면:
1. `MY_USER_ID`가 올바른지 확인
2. 복호화 로직을 서버와 동일하게 맞추기
3. 더 많은 `enc` 후보 시도

